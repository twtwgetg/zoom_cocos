    /**
     * 检查并消除符合条件的卡牌组合
     */
    private async checkAndEliminate(): Promise<void> {
        if (!this.creator) return;
        
        // 获取所有可消除的卡牌组合
        const eliminableCards = this.findEliminableCards();
        
        if (eliminableCards.length > 0) {
            // 消除卡牌
            for (const card of eliminableCards) {
                card.released = true;
                // 更新地图数据
                gridcreator.map[card.x + 1][card.y + 1] = 0;
                // 从场景中移除
                card.node.removeFromParent();
                card.node.destroy();
            }
            
            // 触发积分增加事件
            Main.DispEvent('event_add_jifen');
            
            // 让上方的卡牌下落
            await this.dropCardsDown();
            
            // 生成新的卡牌填充空位
            this.generateNewCards();
            
            // 继续检查是否还有可消除的组合
            await this.checkAndEliminate();
        }
    }
    
    /**
     * 查找所有可消除的卡牌组合
     */
    private findEliminableCards(): TObject[] {
        if (!this.creator) return [];
        
        const eliminableCards: TObject[] = [];
        const processedCards = new Set<TObject>();
        
        // 检查横向连续三个或以上相同类型的卡牌
        for (let y = 0; y < (this.creator as any).infiniteHei; y++) {
            let count = 1;
            let currentType = -1;
            const sameTypeCards: TObject[] = [];
            
            for (let x = 0; x < (this.creator as any).infiniteWid; x++) {
                const card = this.findCardAt(x, y);
                if (card && !card.released) {
                    if (card.type === currentType) {
                        count++;
                        sameTypeCards.push(card);
                    } else {
                        // 检查之前的连续卡牌是否达到消除条件
                        if (count >= 3 && currentType !== -1) {
                            for (const c of sameTypeCards) {
                                if (!processedCards.has(c)) {
                                    eliminableCards.push(c);
                                    processedCards.add(c);
                                }
                            }
                        }
                        
                        // 重置计数
                        count = 1;
                        currentType = card.type;
                        sameTypeCards.length = 0;
                        sameTypeCards.push(card);
                    }
                } else {
                    // 空位或已消除的卡牌，检查之前的连续卡牌
                    if (count >= 3 && currentType !== -1) {
                        for (const c of sameTypeCards) {
                            if (!processedCards.has(c)) {
                                eliminableCards.push(c);
                                processedCards.add(c);
                            }
                        }
                    }
                    
                    // 重置计数
                    count = 1;
                    currentType = -1;
                    sameTypeCards.length = 0;
                }
            }
            
            // 检查最后一组连续卡牌
            if (count >= 3 && currentType !== -1) {
                for (const c of sameTypeCards) {
                    if (!processedCards.has(c)) {
                        eliminableCards.push(c);
                        processedCards.add(c);
                    }
                }
            }
        }
        
        // 检查纵向连续三个或以上相同类型的卡牌
        for (let x = 0; x < (this.creator as any).infiniteWid; x++) {
            let count = 1;
            let currentType = -1;
            const sameTypeCards: TObject[] = [];
            
            for (let y = 0; y < (this.creator as any).infiniteHei; y++) {
                const card = this.findCardAt(x, y);
                if (card && !card.released) {
                    if (card.type === currentType) {
                        count++;
                        sameTypeCards.push(card);
                    } else {
                        // 检查之前的连续卡牌是否达到消除条件
                        if (count >= 3 && currentType !== -1) {
                            for (const c of sameTypeCards) {
                                if (!processedCards.has(c)) {
                                    eliminableCards.push(c);
                                    processedCards.add(c);
                                }
                            }
                        }
                        
                        // 重置计数
                        count = 1;
                        currentType = card.type;
                        sameTypeCards.length = 0;
                        sameTypeCards.push(card);
                    }
                } else {
                    // 空位或已消除的卡牌，检查之前的连续卡牌
                    if (count >= 3 && currentType !== -1) {
                        for (const c of sameTypeCards) {
                            if (!processedCards.has(c)) {
                                eliminableCards.push(c);
                                processedCards.add(c);
                            }
                        }
                    }
                    
                    // 重置计数
                    count = 1;
                    currentType = -1;
                    sameTypeCards.length = 0;
                }
            }
            
            // 检查最后一组连续卡牌
            if (count >= 3 && currentType !== -1) {
                for (const c of sameTypeCards) {
                    if (!processedCards.has(c)) {
                        eliminableCards.push(c);
                        processedCards.add(c);
                    }
                }
            }
        }
        
        return eliminableCards;
    }
    
    /**
     * 根据坐标查找卡牌
     */
    private findCardAt(x: number, y: number): TObject | null {
        if (!this.creator) return null;
        
        const children = this.creator.node.children;
        for (const child of children) {
            const card = child.getComponent(TObject);
            if (card && card.x === x && card.y === y) {
                return card;
            }
        }
        return null;
    }
    
    /**
     * 让卡牌下落
     */
    private async dropCardsDown(): Promise<void> {
        if (!this.creator) return;
        
        // 从下往上处理每一列
        for (let x = 0; x < (this.creator as any).infiniteWid; x++) {
            // 收集这一列的所有卡牌
            const columnCards: TObject[] = [];
            for (let y = 0; y < (this.creator as any).infiniteHei; y++) {
                const card = this.findCardAt(x, y);
                if (card && !card.released) {
                    columnCards.push(card);
                }
            }
            
            // 重新排列卡牌位置，让它们落到最下面
            for (let i = 0; i < columnCards.length; i++) {
                const card = columnCards[i];
                const newY = (this.creator as any).infiniteHei - columnCards.length + i;
                
                // 更新地图数据
                gridcreator.map[card.x + 1][card.y + 1] = 0;
                gridcreator.map[card.x + 1][newY + 1] = card.type;
                
                // 更新卡牌属性
                card.y = newY;
                card.node.name = `${card.x},${card.y}`;
                
                // 更新位置
                const pos = this.creator.tref.add(new Vec2((card.x) * this.creator.gridsize, (card.y) * this.creator.gridsize));
                card.node.setPosition(pos.x, pos.y);
            }
        }
        
        // 等待一小段时间，让下落动画完成
        await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    /**
     * 生成新的卡牌填充空位
     */
    private generateNewCards(): void {
        if (!this.creator) return;
        
        // 从上往下处理每一列的空位
        for (let x = 0; x < (this.creator as any).infiniteWid; x++) {
            // 计算这一列有多少个空位
            let emptyCount = 0;
            for (let y = 0; y < (this.creator as any).infiniteHei; y++) {
                const card = this.findCardAt(x, y);
                if (!card || card.released) {
                    emptyCount++;
                }
            }
            
            // 在顶部生成新的卡牌
            for (let i = 0; i < emptyCount; i++) {
                const y = emptyCount - i - 1;
                
                // 随机生成卡牌类型
                const availableTypes = this.creator.pl.length - 1;
                if (availableTypes >= 1) {
                    const type = Math.floor(Math.random() * availableTypes) + 1;
                    
                    // 更新地图数据
                    gridcreator.map[x + 1][y + 1] = type;
                    
                    // 生成新卡牌
                    const mapPos = new Vec2(x + 1, y + 1);
                    this.creator.SpawnCard(mapPos, type);
                }
            }
        }
    }
    
    start() {
        //响应鼠标点击事件
        this.getComponent(Button)!.node.on('click',this.onButtonClick, this);
    }
 
    SetSprite(i: number, j: number, _tp: number, xx: SpriteFrame, _creator: gridcreator): void {
        this.type = _tp;
        this.creator = _creator;
        this.x = i;
        this.y = j;
        this.src.spriteFrame = xx;
    }
    update(deltaTime: number) {
        
    }
}